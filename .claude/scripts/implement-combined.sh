#!/bin/bash

# Combined Implementation Script
# Automatically implements multiple sections into a single HTML file

set -e

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
NC='\033[0m'

# Load utilities
source "$(dirname "$0")/figma-utils.sh" 2>/dev/null || true

echo -e "${PURPLE}⚡ Figma to Liquid - Auto Combined Implementation${NC}\n"

# Function to find next parent component to implement
find_next_parent() {
  # Check if index.json exists
  if [ ! -f .claude/tasks/index.json ]; then
    echo -e "${RED}❌ No tasks found. Run /breakdown first.${NC}" >&2
    exit 1
  fi

  # Get all task JSON files directly
  local task_files=$(ls .claude/tasks/task*.json 2>/dev/null || echo "")

  if [ -z "$task_files" ]; then
    echo -e "${RED}❌ No task files found.${NC}" >&2
    exit 1
  fi

  # Group tasks by parent component and find first pending/in-progress
  local parent=""
  for task_file in $task_files; do
    if [ ! -f "$task_file" ]; then
      continue
    fi

    local task_data=$(cat "$task_file")
    local status=$(echo "$task_data" | jq -r '.status // "pending"')
    local parent_component=$(echo "$task_data" | jq -r '.parentComponent // empty')

    # Skip completed tasks
    if [ "$status" = "completed" ]; then
      continue
    fi

    # Use parent component if available
    if [ -n "$parent_component" ] && [ "$parent_component" != "null" ]; then
      parent=$parent_component
      break
    fi
  done

  if [ -z "$parent" ]; then
    echo -e "${YELLOW}⚠️  All tasks completed!${NC}" >&2
    exit 0
  fi

  # Convert parent to slug format
  echo "$parent" | sed 's/[^a-zA-Z0-9]/-/g' | tr '[:upper:]' '[:lower:]' | sed 's/--*/-/g' | sed 's/^-//' | sed 's/-$//'
}

# Get parent component from argument or auto-detect
PARENT_SLUG=$1

if [ -z "$PARENT_SLUG" ]; then
  echo -e "${BLUE}Auto-detecting next component to implement...${NC}\n"
  PARENT_SLUG=$(find_next_parent)
  echo -e "${GREEN}✓ Selected: $PARENT_SLUG${NC}\n"
fi

echo -e "${BLUE}Parent Component:${NC} $PARENT_SLUG\n"

# Find all related task files
TASK_FILES=$(ls .claude/tasks/task*.json 2>/dev/null || echo "")

if [ -z "$TASK_FILES" ]; then
  echo -e "${RED}❌ No task files found.${NC}"
  exit 1
fi

# Get all task files and filter by parent
MATCHING_TASKS=""

for task_file in $TASK_FILES; do
  if [ ! -f "$task_file" ]; then
    continue
  fi

  task_data=$(cat "$task_file")
  slug=$(echo "$task_data" | jq -r '.slug // empty')
  parent=$(echo "$task_data" | jq -r '.parentComponent // empty')

  # Match by slug pattern or parent component
  if [[ "$slug" == "$PARENT_SLUG"* ]] || [ "$parent" = "$PARENT_SLUG" ]; then
    MATCHING_TASKS="$MATCHING_TASKS $task_file"
  fi
done

if [ -z "$MATCHING_TASKS" ]; then
  echo -e "${RED}❌ No tasks found for parent: $PARENT_SLUG${NC}"
  echo -e "${YELLOW}Available parents:${NC}"
  for task_file in $TASK_FILES; do
    if [ ! -f "$task_file" ]; then
      continue
    fi
    task_data=$(cat "$task_file")
    parent=$(echo "$task_data" | jq -r '.parentComponent // .title // empty')
    if [ -n "$parent" ]; then
      echo "  - $parent"
    fi
  done | sort -u
  exit 1
fi

TASK_COUNT=$(echo "$MATCHING_TASKS" | wc -w | tr -d ' ')
echo -e "${GREEN}Found $TASK_COUNT sections to combine${NC}\n"

# Sort tasks by section number
SORTED_TASKS=$(for task_file in $MATCHING_TASKS; do
  task_data=$(cat "$task_file")
  section_num=$(echo "$task_data" | jq -r '.sectionNumber // 0')
  echo "$section_num:$task_file"
done | sort -n | cut -d':' -f2)

# Output files
mkdir -p html html/css html/js html/assets tests
COMBINED_HTML="html/${PARENT_SLUG}.html"
COMBINED_CSS="html/css/${PARENT_SLUG}.css"
COMBINED_JS="html/js/${PARENT_SLUG}.js"
COMBINED_TEST="tests/${PARENT_SLUG}.spec.js"

# Create assets directories for each task
echo -e "${BLUE}Creating assets directories...${NC}"
for task_file in $SORTED_TASKS; do
  task_data=$(cat "$task_file")
  SECTION_SLUG=$(echo "$task_data" | jq -r '.slug')
  mkdir -p "html/assets/${SECTION_SLUG}"
  echo -e "  ${GREEN}✓ html/assets/${SECTION_SLUG}/${NC}"
done
echo ""

echo -e "${BLUE}Creating combined files...${NC}"

# Initialize combined HTML
cat > "$COMBINED_HTML" << EOF
<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${PARENT_SLUG}</title>
  <link rel="stylesheet" href="css/${PARENT_SLUG}.css">
</head>
<body>
  <main class="${PARENT_SLUG}">
EOF

# Initialize CSS
cat > "$COMBINED_CSS" << EOF
/* Combined CSS for $PARENT_SLUG */
/* Auto-generated by /implement-combined */

.${PARENT_SLUG} {
  width: 100%;
  margin: 0;
  padding: 0;
}

EOF

# Initialize JS
cat > "$COMBINED_JS" << EOF
/* Combined JavaScript for $PARENT_SLUG */
/* Auto-generated by /implement-combined */
(function() {
  'use strict';

EOF

# Process each section in order
# NOTE: Claude should download assets and fetch code via Figma MCP for each section
# - Use mcp__figma-dev-mode-mcp-server__get_screenshot to download screenshot
# - Use mcp__figma-dev-mode-mcp-server__get_code to fetch actual HTML/CSS/JS
SECTION_NUM=1
for task_file in $SORTED_TASKS; do
  echo -e "${BLUE}  Processing section $SECTION_NUM...${NC}"

  task_data=$(cat "$task_file")

  NODE_ID=$(echo "$task_data" | jq -r '.nodeId')
  SECTION_SLUG=$(echo "$task_data" | jq -r '.slug')
  SECTION_TITLE=$(echo "$task_data" | jq -r '.title')
  PARENT_COMPONENT=$(echo "$task_data" | jq -r '.parentComponent')

  if [ -z "$NODE_ID" ] || [ "$NODE_ID" = "null" ]; then
    echo -e "${YELLOW}    ⚠️  Skipping - no node ID${NC}"
    continue
  fi

  echo -e "    ${GREEN}Node: $NODE_ID - $SECTION_TITLE${NC}"
  echo -e "    ${YELLOW}📸 Assets folder: html/assets/${SECTION_SLUG}/${NC}"
  echo -e "    ${YELLOW}TODO: Download screenshot and code via Figma MCP${NC}"

  # Get frame width from Figma file (if available)
  FRAME_WIDTH=1440
  if [ -f logs/figma-full-file.json ]; then
    FRAME_WIDTH=$(jq -r --arg nid "$NODE_ID" '
      [.. | objects | select(.id == $nid)] | .[0] |
      .absoluteBoundingBox.width // 1440
    ' logs/figma-full-file.json 2>/dev/null || echo "1440")
  fi

  # Determine if container is needed (simple heuristic: width < 1400 = needs container)
  NEEDS_CONTAINER="false"
  if [ $(echo "$FRAME_WIDTH < 1400" | bc -l) -eq 1 ]; then
    NEEDS_CONTAINER="true"
  fi

  # Generate section HTML
  cat >> "$COMBINED_HTML" << EOF

    <!-- Section $SECTION_NUM: $SECTION_TITLE -->
    <!-- Node ID: $NODE_ID -->
    <section class="${PARENT_SLUG}__section" data-section="$SECTION_NUM" data-node-id="$NODE_ID">
EOF

  if [ "$NEEDS_CONTAINER" = "true" ]; then
    cat >> "$COMBINED_HTML" << EOF
      <div class="${PARENT_SLUG}__container" style="max-width: ${FRAME_WIDTH}px;">
        <!-- TODO: Implement $SECTION_TITLE -->
        <div class="section-placeholder">
          <p>Section $SECTION_NUM: $SECTION_TITLE</p>
          <p>Node ID: $NODE_ID</p>
        </div>
      </div>
EOF
  else
    cat >> "$COMBINED_HTML" << EOF
      <!-- TODO: Implement $SECTION_TITLE -->
      <div class="section-placeholder" style="max-width: ${FRAME_WIDTH}px;">
        <p>Section $SECTION_NUM: $SECTION_TITLE</p>
        <p>Node ID: $NODE_ID</p>
      </div>
EOF
  fi

  cat >> "$COMBINED_HTML" << EOF
    </section>
EOF

  # Add section CSS
  cat >> "$COMBINED_CSS" << EOF

/* =============================================
   Section $SECTION_NUM: $SECTION_TITLE
   Node ID: $NODE_ID
   Parent: $PARENT_COMPONENT
   ============================================= */

.${PARENT_SLUG}__section[data-section="$SECTION_NUM"] {
  width: 100%;
  margin: 0 auto;
  max-width: ${FRAME_WIDTH}px;
}

EOF

  if [ "$NEEDS_CONTAINER" = "true" ]; then
    cat >> "$COMBINED_CSS" << EOF
.${PARENT_SLUG}__section[data-section="$SECTION_NUM"] .${PARENT_SLUG}__container {
  width: 100%;
  max-width: ${FRAME_WIDTH}px;
  margin: 0 auto;
  padding: 0 16px;
  box-sizing: border-box;
}

EOF
  fi

  # Add placeholder styles
  cat >> "$COMBINED_CSS" << EOF
.${PARENT_SLUG}__section[data-section="$SECTION_NUM"] .section-placeholder {
  padding: 40px;
  background: #f0f0f0;
  border: 2px dashed #ccc;
  text-align: center;
  color: #666;
}

EOF

  # Add section JS
  cat >> "$COMBINED_JS" << EOF
  // Section $SECTION_NUM: $SECTION_TITLE (Node: $NODE_ID)
  function initSection${SECTION_NUM}() {
    const section = document.querySelector('[data-section="$SECTION_NUM"]');
    if (!section) {
      console.warn('Section $SECTION_NUM not found');
      return;
    }

    // TODO: Add section-specific initialization
    console.log('Section $SECTION_NUM initialized:', section);
  }

EOF

  # Update task status to in_progress
  jq '.status = "in_progress" | .phase = "implementation" | .updated = (now | todate)' \
    "$task_file" > "${task_file}.tmp"
  mv "${task_file}.tmp" "$task_file"

  SECTION_NUM=$((SECTION_NUM + 1))
done

# Close HTML
cat >> "$COMBINED_HTML" << EOF

  </main>
  <script src="js/${PARENT_SLUG}.js"></script>
</body>
</html>
EOF

# Close JS with auto-initialization
cat >> "$COMBINED_JS" << EOF

  // Auto-initialize all sections on DOM ready
  document.addEventListener('DOMContentLoaded', function() {
    console.log('Initializing ${PARENT_SLUG}...');

    const sections = document.querySelectorAll('[data-section]');
    console.log('Found ' + sections.length + ' sections');

    sections.forEach(function(section) {
      const sectionNum = section.getAttribute('data-section');
      const initFn = window['initSection' + sectionNum];

      if (typeof initFn === 'function') {
        initFn();
      }
    });

    console.log('${PARENT_SLUG} initialized');
  });

})();
EOF

# Create basic Playwright test
cat > "$COMBINED_TEST" << EOF
const { test, expect } = require('@playwright/test');

test.describe('${PARENT_SLUG}', () => {
  test.beforeEach(async ({ page }) => {
    await page.goto('file://' + process.cwd() + '/html/${PARENT_SLUG}.html');
  });

  test('should load all sections', async ({ page }) => {
    const sections = await page.locator('[data-section]').count();
    expect(sections).toBe(${SECTION_NUM} - 1);
  });

  test('should have correct title', async ({ page }) => {
    await expect(page).toHaveTitle('${PARENT_SLUG}');
  });

  test('should initialize JavaScript', async ({ page }) => {
    const logs = [];
    page.on('console', msg => logs.push(msg.text()));

    await page.waitForLoadState('networkidle');

    expect(logs.some(log => log.includes('${PARENT_SLUG} initialized'))).toBe(true);
  });

  // TODO: Add visual regression tests
  // test('should match screenshot', async ({ page }) => {
  //   await expect(page).toHaveScreenshot('${PARENT_SLUG}.png');
  // });
});
EOF

echo ""
echo -e "${GREEN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
echo -e "${GREEN}Combined Implementation Scaffolding Complete!${NC}"
echo -e "${GREEN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
echo ""
echo -e "${BLUE}Files Created:${NC}"
echo -e "  📄 $COMBINED_HTML"
echo -e "  🎨 $COMBINED_CSS"
echo -e "  ⚙️  $COMBINED_JS"
echo -e "  🧪 $COMBINED_TEST"
echo ""
echo -e "${BLUE}Sections Included:${NC} $(($SECTION_NUM - 1))"
echo ""
echo -e "${YELLOW}Next Steps (Claude should do this automatically):${NC}"
echo -e "  1. Download assets for each section:"
echo -e "     ${BLUE}Use mcp__figma-dev-mode-mcp-server__get_screenshot${NC}"
echo -e "     ${BLUE}Save to: html/assets/{section-slug}/screenshot.png${NC}"
echo -e ""
echo -e "  2. Fetch actual code for each section:"
echo -e "     ${BLUE}Use mcp__figma-dev-mode-mcp-server__get_code${NC}"
echo -e "     ${BLUE}Replace placeholders with actual HTML/CSS/JS${NC}"
echo -e ""
echo -e "  3. Test the combined page:"
echo -e "     ${BLUE}npx playwright test tests/${PARENT_SLUG}.spec.js${NC}"
echo -e ""
echo -e "  4. Add visual regression tests"
echo -e ""
echo -e "  5. When complete, convert to Liquid:"
echo -e "     ${BLUE}/to-liquid ${PARENT_SLUG}${NC}"
echo ""
echo -e "${GREEN}✨ Scaffolding ready - Claude should now fetch assets and code from Figma!${NC}"
echo ""

# Show which component is next if this was auto-detected
if [ -z "$1" ]; then
  echo -e "${BLUE}To continue with next component, run:${NC}"
  echo -e "  ${BLUE}/implement-combined${NC}"
  echo ""
fi
